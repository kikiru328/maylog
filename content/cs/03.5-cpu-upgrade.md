---
title: CPU 성능 향상시키기
aliases:
  - cpu-upgrade
description: CPU의 성능은 어떻게 향상 시킬 수 있을까?
draft: false
tags:
  - CS/computer
permalink: /cpu-upgrade
created: 2025-03-22T15:16
updated: 2025-05-07T16:18
socialImage: https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWtxZnd0MmpsbG1leHAzODU2M2hsc21pYjBhY3VzMzIzbDFxbzlxZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/5tvJS6ZZslR9nBYxUA/giphy.gif
---
<p align="center">
  <img src="https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExZWtxZnd0MmpsbG1leHAzODU2M2hsc21pYjBhY3VzMzIzbDFxbzlxZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/5tvJS6ZZslR9nBYxUA/giphy.gif" alt="note title" width="300">
</p>

# CPU의 성능을 향상 시키자

현재는 CPU와 [[07-GPU|GPU]]를 통합하여 좋은 컴퓨터 환경을 만들고 있다. 하지만 GPU 없이 컴퓨터는 잘 돌아가지만 CPU가 없으면 부팅조차 되지 않는다. 따라서 CPU의 중요도가 압도적으로 높다. 그렇기에 좋은 CPU를 사용하지만, 더욱 더 잘 활용하기 위해서는 클럭, 코어, 스레드 등 여러 CPU 성능 향상 기법을 알고 있는 것이 좋다.

## 클럭

CPU 살 때, `클럭`이라는 말을 들어 봤을 것이다. 클럭이란, 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 **시간의 단위**를 의미한다. 그러니까, 쉽게 말하면 **속도**다. 클럭이 1초에 몇 번 반복되는지 헤르츠 단위(Hz) 단위로 측정되는데, 현재는 너무 빨라서 기가 헤르츠 (GHz)로 표현한다.

클럭 속도가 높아지면 어떻게 될까. CPU는 명령어의 사이클을 더욱 빠르게 반복할 것이고, 다른 장치들도 그 속도에 맞추어 더 빠르게 작동할 것이다. 즉, 클럭이 높을 수록 CPU의 성능이 높아진다.

그렇다면 클럭을 올릴 수 있는 최대한으로 올리면 컴퓨터의 성능이 향상되는가? 되긴 하지만 문제가 있다. **오버 클럭**이라는 말을 들어봤을 것이다. 기본 CPU의 정상 클럭 속도 이상으로 올리는 방법인데, 오버 클럭시 CPU의 성능이 향상되기는 한다. 하지만 언제나 장점만 있을 순 없는 법. 클럭 속도가 높아짐에 따라 **발열**문제가 있기 때문에 CPU의 버전에 따라 클럭과 쿨러를 잘 구성해야 한다.

## 멀티 코어 & 스레드: CPU 노예

코어와 스레드 또한 CPU에서 많이 들어본 내용이다. CPU의 성능에 가장 가까운 의미를 내포하는데, 그렇다면 코어와 스레드는 무엇일까?

코어와 스레드를 노예라고 생각해보자. 노예의 수가 많아지면 많아질 수록 작업의 처리 양은 더 빠르고 많아질 것이다. 만약 노예가 외계인이라 팔이 여러 개가 있을 수 있다고 생각해보자. 일반적으로 팔이 두 개인 노예로 구성된 집단 보다는 팔이 4개, 8개 있는 노예 집단이 여러 개의 작업을 동시에 할 수 있을 것이다.

이 논리를 그대로 적용하면 된다. 코어는 노예의 수, 스레드는 노예의 팔이다. 다시 말해, **코어**는 CPU내에서 명령어를 읽고 해석하고 실행하는 CPU의 중요한 부분이다. 한 CPU에 여러 개로 구성될 수 있다. **스레드**는 실행 흐름의 단위를 의미한다. 하드웨어 스레드 (=스레드)는 하나의 코어가 **동시에** 처리하는 명령어의 단위를 의미한다 (논리 프로세서).

즉, 실행하는 부품이 한 번에 하나만 처리가 가능하다면 1코어 1스레드 CPU, 2개의 부품이 한 번에 동시에 두 개를 처리할 수 있다면 2코어 4스레드 CPU라고 의미한다.

스레드는 하드웨어 스레드만 있는게 아니다. 소프트웨어 스레드도 있다. 하드웨어 스레드와는 달리 **소프트웨어 스레드**는 하나의 프로그램에서 독립적으로 실행하는 단위를 의미한다. 이 말은 즉, "어떤 프로그램이 여러 스레드를 통해 실행될 수 있다"를 의미하는 것이고, 달리 말하면 **"메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다**라는 것이다. 

소프트웨어 스레드는 여러 스레드를 통해 실행될 수 있다는 것이다. 즉, 1코어 1스레드라도 스레드로 실행이 가능하다는 것을 의미한다. (번갈아가면서 처리를 나누어서 진행한다고 생각하면 쉽다)

따라서 하드웨어 스레드와 소프트웨어 스레드는 **병렬성**과 **동시성**로 구분할 수 있다. 같은 시점에 여러 작업을 동시에 처리할 수 있는 하드웨어 스레드는 병렬성을 의미하고, 동시에 작업을 하는 것 처럼 보이는 것은 소프트웨어 스레드에 가깝다고 볼 수 있다.

## 파이프라이닝으로 병렬 처리

그래서 **명령어 병렬 처리 기법**인 **명령어 파이프라이닝**기법이 나온다. 여러 명령어를 동시에 처리하여 CPU를 한시도 가만히 두지 않는 것이다. 명령어는 인출, 해석, 실행, 저장의 단계로 나눌 수 있는데, 겹치지만 않으면 CPU는 각각의 단계를 동시에 실행할 수 있다는 점이다. 이를 이용해서 `[인출, 해석, 실행, 저장]`을 하나로 묶고, 이들을 병렬로 처리하게 하는 것이다. (겹치지만 않게)

이러한 파이프라이닝을 비롯한 명령어 병렬 처리에는 유리한 명령어 집합과 불리한 명령어 집합이 있다. 각각의 CPU마다 다르긴 하지만 크게는 다음과 같다. 

| 구분   |                                  |              |               |
| ---- | -------------------------------- | ------------ | ------------- |
| CISC | Complex Instruction Set Computer | x86, x86-64  | 다채로운 기능 지원    |
| RISC | Reduced Instruction Set Computer | Apple M1 CPU | CISC보단 적은 명령어 |

이 특징만 보았을 때, RISC는 CISC보다 많은 명령어가 필요해 보인다. 하지만 CISC는 다채롭지만 복잡하기에 각각의 단계의 실행 속도가 일정하지 않기에 여러 클럭 주기가 필요하고, 이로 인해 파이프라이닝에 비효율적이다. 반면 RISC는 규격화되어 있어 하나의 명령어가 1클럭 내외로 실행되어 파이프라이닝에 효율적인 특징을 갖는다. ^cisc-risc

#### 실패하는 경우

파이프라이닝은 무조건 성공하는 기법은 아니다. 파이프라이닝을 적용해도 성능 향상이 이루어지지 않는 경우가 있는데, 이를 **파이프라인 위험**이라고 한다. 이는 **데이터 위험**과 **제어 위험**, **구조 위험**(자원 위험)으로 구분된다.

데이터 위험은 **의존성**에 의해 발생된다. 가령 첫 파이프라인이 완료되고 데이터가 저장되어야만 실행할 수 있다면, 데이터 위험이 발생하고, 파이프라인이 제대로 실행되지 않는다. 

제어 위험은 [[03.3-register#^program-counter|프로그램 카운터]]의 갑작스러운 변화로 발생한다. Jump나 인터럽트 등으로 프로그램 실행 흐름에 변화가 생기면 미리 인출, 해석 중인 명령어는 그 의미가 사라진다.

구조 위험은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 [[03.1-ALU|ALU]], [[03.3-register|레지스터]]와 같은 CPU 부품을 사용하려고 할 때 발생한다

</br></br></br>
# 참고자료
※ 이 글은 [『이것이 컴퓨터 과학이다』](https://product.kyobobook.co.kr/detail/S000214014967) 책을 기반으로, 다양한 자료를 참고해 작성했습니다.