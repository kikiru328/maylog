---
title: CPU
aliases:
  - cpu
description: 컴퓨터의 뇌, CPU
draft: false
tags:
  - CS/computer
permalink: /cpu
created: 2025-04-21T23:59
updated: 2025-04-27T22:57
socialImage: https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExOW5ueTljc2tkM2ZmaTE3aXMzdnU0YmZnOWZidm5jandvNjUxMTl5cSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/n6szplK2CnuJW/giphy.gif
---
<p align="center">
  <img src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExOW5ueTljc2tkM2ZmaTE3aXMzdnU0YmZnOWZidm5jandvNjUxMTl5cSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/n6szplK2CnuJW/giphy.gif" alt="cpu" width="300">
</p>

# 구성요소

컴퓨터는 **수행할 동작과 그 대상 데이터**를 담은 명령어로 동작한다. 정적인 정보인 **데이터**를 동적 정보인 **명령어**와 함께 전달한다. 두 정보는 0과 1로 이루어져 있으며, 이는 **CPU**가 주체가 되어 실행한다. 즉, CPU의 종류에 따라 실행 가능한 세부적인 명령어의 종류가 다르며 처리의 양상이 달라진다.

**CPU**(Central Processing Unit)는 중앙 처리 부품을 의미한다. CPU는 주요 구성 요소와 빠른 명령어 처리를 위한 기술이 중점적인 부품이다. 크게 CPU 내부는 [[3.1-ALU|산술논리연산장치(ALU)]]와 제어 장치를 포함한 여러 레지스터들이 있다.

| CPU 구성 요소                                    |                               |     |
| -------------------------------------------- | ----------------------------- | --- |
| 산술논리연산장치<br>(ALU, Arithmetic and Logic Unit) | 실질적으로 연산을 수행                  |     |
| 제어장치<br>(CU, Control Unit)                   | 명령어를 해석, 제어 신호를 통해 부품을 작동.    |     |
| **레지스터(register)**                           | 작은 임시 저장장치, 처리하는 과정의 중간 값 저장. |     |

CPU의 구성 요소 중, **레지스터**는 CPU에서 매우 중요한 부품이다. 여기에 CPU가 처리하는 과정의 모든 중간 값들이 이 곳에 저장되기 때문이다.

## 레지스터란 무엇인가?

레지스터는 CPU에서 다양한 이름과 역할로서 분리되어 있다. 대표적인 레지스터는 다음과 같다.

1. **프로그램 카운터**
프로그램 카운터는 [[4-memory|메모리]]에서 다음으로 읽어 들일 [[2-readable-data#^address-def|명령어의 주소]]를 저장한다. (**명령어 포인트**라고 부르기도 함). 
</br></br>
2. **명령어 레지스터**
해석할 명령어를 저장하는 레지스터를 의미한다.   
CPU는 명령어 레지스터 속 명령어를 해석한 뒤, ALU, 산술 논리 연산 장치로 하여금 연산하도록 하거나 제어 신호를 전송한다.
</br></br>
3. **범용 레지스터**
일반적인 상황에서 사용할 수 있는 레지스터다. 데이터와 명령어, 주소를 모두 저장할 수 있다.
</br></br>
4. **플래그 레지스터**
연산의 결과 혹은 CPU 상태에 대한 부가 정보, 플래그 값을 저장한다.  
플래그는 CPU가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보를 의미한다. 
^flag-register-def

| 플래그 레지스터     |                               |
| ------------ | ----------------------------- |
| 부호 플래그       | 연산 결과의 부호                     |
| 제로 플래그       | 연산 결과가 0인지                    |
| 캐리 플래그       | 연산 결과에 올림수나 빌림수가 발생했는지        |
| 오버플로우 플래그    | 오버플로우 발생 여부                   |
| **인터럽트** 플래그 | 인터럽트 가능 여부                    |
| 슈퍼바이저 플래그    | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 |

5. **스택 포인터**
메모리에서는 실행 중인 프로그램이 **적재**되어 있다. 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가르키는 레지스터가 바로 **스택 포인터**다. 

## 인터럽트란 무엇인가? 왜 중요한가 
^interrupt-def

앞서 CPU를 구성하는 요소 중 레지스터가 중요하고, 레지스터에서 **인터럽트 사이클**이 중요하다고 언급했다.   
그렇다면 인터럽트란 무엇일까?

**인터럽트(interrupt)** 는 **CPU가 수행 중인 작업을 일시 중단시키는 신호** 다. 인터럽트는 크게 **동기 인터럽트 (synchronous interrupt)** 와 **비동기 인터럽트 (asynchronous interrupt)** 로 나누어진다.

동기 인터럽트는 CPU에 의해서 발생된다. 예외적인 상황이나 프로그램 오류에 의해서 발생된다. 우리가 쉽게 마주치는 "Exception"이 해당된다.

비동기 인터럽트는 주로 입출력 장치에 의해 발생한다. 작업의 알림과 같은 역할을 하는 것이다. 즉, 비동기 인터럽트의 다른 말로는 **하드웨어 인터럽트**라고 한다.

### 하드웨어 인터럽트: 효율적 관리

CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다. 우리가 자주 사용하는 전자레인지를 예로 들어보자. 우리는 전자레인지에 음식을 넣고 돌리는 동안 다른 일을 한다. 그리고 완료가 되는 소리에 의해 전자레인지에서 음식을 꺼낸다. 여기서 완료되었다고 알림을 보내는 것이 **하드웨어 인터럽트**다. 만약에 하드웨어 인터럽트를 사용하지 않았다면, 우리는 계속해서 전자레인지를 확인해야 하기 때문에 다른 일을 하지 못하는 매우 비효율적인 행동을 해야 한다. (주기적으로 확인하는 기법: polling). CPU도 마찬가지다. 여러 종류의 인터럽트가 있기는 하지만, 처리하는 순서는 동일하다.

1. 입출력장치 -> CPU에게 인터럽트 요청 신호
2. CPU는 실행 사이클을 종료, 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인 후 **인터럽트 플래그**를 통해 인터럽트 수용 여부 확인
4. 가능하면 CPU가 작업 백업
5. CPU는 인터럽트 백터를 참조, 서비스 루틴 실행
6. 루틴이 끝나면 백업된 작업 재개

>[!note] 반대로, **Polling 기법**은 장치가 아닌 CPU가 직접 장치를 주기적으로 체크하는 방식이다.  
> 하드웨어 인터럽트가 "알림을 기다리는" 방식이라면, 폴링은 "직접 계속 확인하는" 방식인 셈이다. 단순한 시스템이나 테스트 환경에서는 유용하지만, 자원 낭비 측면에서 비효율적이기 때문에 잘 사용하지 않는다.

인터럽트는 CPU가 작업하고 있는 것을 끊는 것이기 때문에 인터럽트를 해도 괜찮을 지 CPU에게 가능 여부를 확인해야 한다. 그게 바로 **인터럽트 플래그**이다. CPU가 인터럽트 요청을 수행하기 위해선 플래그 레지스터의 인터럽트 플래그가 활성화되어 있어야 한다. 만약 불가능으로 설정되어 있다면 CPU는 모든 인터럽트 요청을 무시하게 된다.

하지만 인터럽트 플래그는 만능이 아니다. 인터럽트는 [[6-io-devices#^NMI-def|무시할 수 없는 인터럽트]]와 무시할 수 있는 인터럽트가 존재한다. 우선순위가 높은 인터럽트, 즉, 정전이나 하드웨어 고장일 경우 생기는 인터럽트는 무시할 수 없는 인터럽트를 의미한다.

CPU가 인터럽트 요청을 받아들인다면, CPU는 **인터럽트 서비스 루틴 (인터럽트 핸들러)** 을 실행한다. 인터럽트를 처리하기 위한 서비스인데, 어떤 인터럽트를 어떻게 처리하고 작동할 지에 대한 정보로 이루어져 있는 프로그램이다. 

입 출력 장치마다 인터럽트를 처리하기 위한 동작이 다르기 때문에, 장치마다 루틴을 가지고 있다. 하지만 하나의 컴퓨터에는 여러 장치들이 연결되어 있기 때문에 이 것 들을 분리해야 한다. 이 때 인터럽트를 분리하는 것이 **인터럽트 벡터**이다. 

모든 인터럽트는 메모리에 저장이 되어있다. CPU는 하드웨어 인터럽트 요청을 받은 대상으로 부터 인터럽트 벡터를 전달 받고, 인터럽트 벡터는 CPU에게 메모리에 저장된 **인터럽트 시작 주소**를 반환한다. 이러한 방식으로 CPU는 각 장치마다 인터럽트 프로그램을 실행할 수 있는 것이다.

CPU는 인터럽트를 실행하기 앞서, 기존에 했던 작업들을 백업을 해야 인터럽트 후 다시 재개를 할 수 있다. 따라서 CPU는 현재 프로그램을 재개하기 위해 모든 내용을 메모리 내 **스택**에 백업한다. 그리고 나서 인터럽트 서비스 루틴을 실행하고, 다시 스택에 저장해 둔 **프로그램 카운터**등을 다시 불러와 이전까지 수행하던 작업을 재개한다.


### 인터럽트의 예외

동기 인터럽트 (Exception)의 종류에는 폴트, 트랩, 중단, 소프트웨어 인터럽트 등이 있다. 각각은 예외가 발생한 명령어부터 실행하는지, 혹은 예외가 발생한 명령어의 다음 명령어부터 실행하는지에 따라 다르다.

| 동기 인터럽트    |                           |
| ---------- | ------------------------- |
| 폴트 (falut) | 예외가 발생한 명령어부터 실행          |
| 트랩 (trap)  | 예외가 발생한 명령어의 다음 명령어부터 실행  |
| 중단 (abort) | 프로그램을 강제로 중단시킬 수 밖에 없을 경우 |
| 소프트웨어 인터럽트 | 시스템 콜이 발생했을 때 발생하는 예외     |

## CPU의 성능을 향상 시키자

현재는 CPU와 GPU를 통합하여 좋은 컴퓨터 환경을 만들고 있다. 하지만 GPU 없이 컴퓨터는 잘 돌아가지만 CPU가 없으면 부팅조차 되지 않는다. 따라서 CPU의 중요도가 압도적으로 높다. 그렇기에 좋은 CPU를 사용하지만, 더욱 더 잘 활용하기 위해서는 클럭, 코어, 스레드 등 여러 CPU 성능 향상 기법을 알고 있는 것이 좋다.

### CPU 클럭 속도

클럭이란, 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 **시간의 단위**를 의미한다. 클럭의 속도는 헤르츠(Hz) 단위로 측정이 되는데, 이는 클럭이 1초에 몇 번 반복되는지를 나타낸다. 현재는 이 클럭 속도가 매우 빨라 기가헤르츠(GHz)단위로 측정하는 것이 일반적이다.

클럭 속도가 높아지면 CPU는 명령어 사이클을 더욱 빠르게 반복하고 다른 장치들도 빠르게 작동할 수 있다. 즉, 높은 클럭은 CPU의 성능과 직결되는 것이다. 하지만 클럭 속도를 필요 이상으로 높일 시 **발열**문제가 있기 때문에 한계가 명확하다.

### 멀티코어와 멀티스레드: CPU 노예
^core-ref

코어 속도는 코어의 수와 스레드 수로 향상 시킬 수 있다. **코어**는 CPU 내에서 명령어를 읽고 해석하고 실행하는 CPU의 중요한 부분을 의미한다. 이 것들은 한 CPU에 여러 개로 구성될 수 있다. (쿼드코어, 옥타코어 등) 코어가 많을 수록 노예가 많다고 생각하면 된다. 우리가 명령한 것들을 이해하는 노예가 많아 일이 더 빠르게 진행하는 것이다.

그렇다면 스레드는 무엇인가? **스레드**는 실행 흐름의 단위를 의미한다. (여기서는 하드웨어 스레드를 의미한다.) 하드웨어 스레드란, 하나의 코어가 **동시에** 처리하는 명령어의 단위를 의미한다. 이는 **논리 프로세서**라고 부르기도 한다. 멀티 스레드는 하나의 코어가 몇 개의 명령어를 동시에 처리할 수 있는지를 의미한다. 즉, 실행하는 부품이 한 번에 하나만 처리가 가능하다면 1코어 1스레드 CPU, 2개의 부품이 한 번에 동시에 두 개를 처리할 수 있다면 2코어 4스레드 CPU라고 의미한다. 쉽게 노예의 팔이 몇 개 인지 생각하면 된다. 한 사람이 한 팔 밖에 없다면 하나의 일 밖에 할 수 없고, 한 사람이 2개의 팔을 가지면 두 개의 일을 동시에 처리할 수 있는 그런 것이다.

하드웨어 스레드와는 달리 **소프트웨어 스레드**는 하나의 프로그램에서 독립적으로 실행하는 단위를 의미한다. 이 말은 즉, "어떤 프로그램이 여러 스레드를 통해 실행될 수 있다"를 의미하는 것이고, 달리 말하면 **"메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다**라는 것이다. 

소프트웨어 스레드는 여러 스레드를 통해 실행될 수 있다는 것이다. 즉, 1코어 1스레드라도 스레드로 실행이 가능하다는 것을 의미한다. (번갈아가면서 처리를 나누어서 진행한다고 생각하면 쉽다)

따라서 하드웨어 스레드와 소프트웨어 스레드는 **병렬성**과 **동시성**로 구분할 수 있다. 같은 시점에 여러 작업을 동시에 처리할 수 있는 하드웨어 스레드는 병렬성을 의미하고, 동시에 작업을 하는 것 처럼 보이는 것은 소프트웨어 스레드에 가깝다고 볼 수 있다.

### 파이프라이닝으로 병렬 처리

그래서 **명령어 병렬 처리 기법**인 **명령어 파이프라이닝**기법이 나온다. 여러 명령어를 동시에 처리하여 CPU를 한시도 가만히 두지 않는 것이다. 명령어는 인출, 해석, 실행, 저장의 단계로 나눌 수 있는데, 겹치지만 않으면 CPU는 각각의 단계를 동시에 실행할 수 있다는 점이다. 이를 이용해서 `[인출, 해석, 실행, 저장]`을 하나로 묶고, 이들을 병렬로 처리하게 하는 것이다. (겹치지만 않게)

이러한 파이프라이닝을 비롯한 명령어 병렬 처리에는 유리한 명령어 집합과 불리한 명령어 집합이 있다. 각각의 CPU마다 다르긴 하지만 크게는 다음과 같다.

| 구분   |                                  |              |               |
| ---- | -------------------------------- | ------------ | ------------- |
| CISC | Complex Instruction Set Computer | x86, x86-64  | 다채로운 기능 지원    |
| RISC | Reduced Instruction Set Computer | Apple M1 CPU | CISC보단 적은 명령어 |
^cisc-risc

이 특징만 보았을 때, RISC는 CISC보다 많은 명령어가 필요해 보인다. 하지만 CISC는 다채롭지만 복잡하기에 각각의 단계의 실행 속도가 일정하지 않기에 여러 클럭 주기가 필요하고, 이로 인해 파이프라이닝에 비효율적이다. 반면 RISC는 규격화되어 있어 하나의 명령어가 1클럭 내외로 실행되어 파이프라이닝에 효율적인 특징을 갖는다.

#### 실패하는 경우

파이프라이닝은 무조건 성공하는 기법은 아니다. 파이프라이닝을 적용해도 성능 향상이 이루어지지 않는 경우가 있는데, 이를 **파이프라인 위험**이라고 한다. 이는 **데이터 위험**과 **제어 위험**, **구조 위험**(자원 위험)으로 구분된다.

데이터 위험은 **의존성**에 의해 발생된다. 가령 첫 파이프라인이 완료되고 데이터가 저장되어야만 실행할 수 있다면, 데이터 위험이 발생하고, 파이프라인이 제대로 실행되지 않는다. 

제어 위험은 **프로그램 카운터의 갑작스러운 변화**로 발생한다. Jump나 인터럽트 등으로 프로그램 실행 흐름에 변화가 생기면 미리 인출, 해석 중인 명령어는 그 의미가 사라진다.

구조 위험은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 **ALU, 레지스터**와 같은 CPU 부품을 사용하려고 할 때 발생한다. 
</br></br></br>
# 참고자료

※ 이 글은 [『이것이 컴퓨터 과학이다』](https://product.kyobobook.co.kr/detail/S000214014967) 책을 기반으로, 다양한 자료를 참고해 작성했습니다.