---
title: CPU
aliases:
  - cpu
description: 컴퓨터의 뇌, CPU
draft: false
tags:
  - CS/computer
permalink: /cpu
created: 2025-04-21T23:59
updated: 2025-05-07T15:56
socialImage: https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExOW5ueTljc2tkM2ZmaTE3aXMzdnU0YmZnOWZidm5jandvNjUxMTl5cSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/n6szplK2CnuJW/giphy.gif
---
<p align="center">
  <img src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExOW5ueTljc2tkM2ZmaTE3aXMzdnU0YmZnOWZidm5jandvNjUxMTl5cSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/n6szplK2CnuJW/giphy.gif" alt="cpu" width="300">
</p>

# CPU 구성요소

컴퓨터는 명령어를 토대로 모든 동작을 수행한다. 즉, 명령어의 구성인 **수행할 동작**과 **대상**을 명시해야 동작할 수 있다는 것이다. 이전에 [[02-readable-data|컴퓨터가 이해할 수 있는 정보]]에서 언급한 것과 같이, 명령어 또한 0과 1로 구성해야 한다는 것이다. 그렇다면 이해할 수 있는 0과 1로 구성된 명령어는 컴퓨터의 어느 부분에서 관리를 할까? 

컴퓨터는 **수행할 동작과 그 대상 데이터**를 담은 명령어로 동작한다. 정적인 정보인 **데이터**를 동적 정보인 **명령어**와 함께 전달한다. 두 정보는 0과 1로 이루어져 있으며, 이는 **CPU**가 주체가 되어 실행한다. 즉, CPU의 종류에 따라 실행 가능한 세부적인 명령어의 종류가 다르며 처리의 양상이 달라진다.

**CPU**(Central Processing Unit)는 중앙 처리 부품을 의미한다. 쉽게 말해 컴퓨터의 "뇌"와 같다. 각종 명령어를 처리할 수 있는 기술이 중점적으로 포함한 하드웨어 부품이다. 명령어는 CPU에서 처리를 한다. 물론 CPU도 하드웨어인 만큼, 종류에 따라 실행 가능한 명령어의 종류가 다르고 처리의 형태가 당연히 다르다.

| CPU 구성 요소                         |                               |     |
| --------------------------------- | ----------------------------- | --- |
| [[03.1-ALU\|산술논리연산장치(ALU)]]       | 실질적으로 연산을 수행                  |     |
| [[03.2-CU\|제어장치(CU)]]             | 명령어를 해석, 제어 신호를 통해 부품을 작동.    |     |
| [[03.3-register\|레지스터(Register)]] | 작은 임시 저장장치, 처리하는 과정의 중간 값 저장. |     |

# CPU의 성능을 향상 시키자

현재는 CPU와 [[07-GPU|GPU]]를 통합하여 좋은 컴퓨터 환경을 만들고 있다. 하지만 GPU 없이 컴퓨터는 잘 돌아가지만 CPU가 없으면 부팅조차 되지 않는다. 따라서 CPU의 중요도가 압도적으로 높다. 그렇기에 좋은 CPU를 사용하지만, 더욱 더 잘 활용하기 위해서는 클럭, 코어, 스레드 등 여러 CPU 성능 향상 기법을 알고 있는 것이 좋다.

### CPU 클럭 속도

클럭이란, 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 **시간의 단위**를 의미한다. 클럭의 속도는 헤르츠(Hz) 단위로 측정이 되는데, 이는 클럭이 1초에 몇 번 반복되는지를 나타낸다. 현재는 이 클럭 속도가 매우 빨라 기가헤르츠(GHz)단위로 측정하는 것이 일반적이다.

클럭 속도가 높아지면 CPU는 명령어 사이클을 더욱 빠르게 반복하고 다른 장치들도 빠르게 작동할 수 있다. 즉, 높은 클럭은 CPU의 성능과 직결되는 것이다. 하지만 클럭 속도를 필요 이상으로 높일 시 **발열**문제가 있기 때문에 한계가 명확하다.

### 멀티코어와 멀티스레드: CPU 노예
^core-ref

코어 속도는 코어의 수와 스레드 수로 향상 시킬 수 있다. **코어**는 CPU 내에서 명령어를 읽고 해석하고 실행하는 CPU의 중요한 부분을 의미한다. 이 것들은 한 CPU에 여러 개로 구성될 수 있다. (쿼드코어, 옥타코어 등) 코어가 많을 수록 노예가 많다고 생각하면 된다. 우리가 명령한 것들을 이해하는 노예가 많아 일이 더 빠르게 진행하는 것이다.

그렇다면 스레드는 무엇인가? **스레드**는 실행 흐름의 단위를 의미한다. (여기서는 하드웨어 스레드를 의미한다.) 하드웨어 스레드란, 하나의 코어가 **동시에** 처리하는 명령어의 단위를 의미한다. 이는 **논리 프로세서**라고 부르기도 한다. 멀티 스레드는 하나의 코어가 몇 개의 명령어를 동시에 처리할 수 있는지를 의미한다. 즉, 실행하는 부품이 한 번에 하나만 처리가 가능하다면 1코어 1스레드 CPU, 2개의 부품이 한 번에 동시에 두 개를 처리할 수 있다면 2코어 4스레드 CPU라고 의미한다. 쉽게 노예의 팔이 몇 개 인지 생각하면 된다. 한 사람이 한 팔 밖에 없다면 하나의 일 밖에 할 수 없고, 한 사람이 2개의 팔을 가지면 두 개의 일을 동시에 처리할 수 있는 그런 것이다.

하드웨어 스레드와는 달리 **소프트웨어 스레드**는 하나의 프로그램에서 독립적으로 실행하는 단위를 의미한다. 이 말은 즉, "어떤 프로그램이 여러 스레드를 통해 실행될 수 있다"를 의미하는 것이고, 달리 말하면 **"메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다**라는 것이다. 

소프트웨어 스레드는 여러 스레드를 통해 실행될 수 있다는 것이다. 즉, 1코어 1스레드라도 스레드로 실행이 가능하다는 것을 의미한다. (번갈아가면서 처리를 나누어서 진행한다고 생각하면 쉽다)

따라서 하드웨어 스레드와 소프트웨어 스레드는 **병렬성**과 **동시성**로 구분할 수 있다. 같은 시점에 여러 작업을 동시에 처리할 수 있는 하드웨어 스레드는 병렬성을 의미하고, 동시에 작업을 하는 것 처럼 보이는 것은 소프트웨어 스레드에 가깝다고 볼 수 있다.

### 파이프라이닝으로 병렬 처리

그래서 **명령어 병렬 처리 기법**인 **명령어 파이프라이닝**기법이 나온다. 여러 명령어를 동시에 처리하여 CPU를 한시도 가만히 두지 않는 것이다. 명령어는 인출, 해석, 실행, 저장의 단계로 나눌 수 있는데, 겹치지만 않으면 CPU는 각각의 단계를 동시에 실행할 수 있다는 점이다. 이를 이용해서 `[인출, 해석, 실행, 저장]`을 하나로 묶고, 이들을 병렬로 처리하게 하는 것이다. (겹치지만 않게)

이러한 파이프라이닝을 비롯한 명령어 병렬 처리에는 유리한 명령어 집합과 불리한 명령어 집합이 있다. 각각의 CPU마다 다르긴 하지만 크게는 다음과 같다.

| 구분   |                                  |              |               |
| ---- | -------------------------------- | ------------ | ------------- |
| CISC | Complex Instruction Set Computer | x86, x86-64  | 다채로운 기능 지원    |
| RISC | Reduced Instruction Set Computer | Apple M1 CPU | CISC보단 적은 명령어 |
^cisc-risc

이 특징만 보았을 때, RISC는 CISC보다 많은 명령어가 필요해 보인다. 하지만 CISC는 다채롭지만 복잡하기에 각각의 단계의 실행 속도가 일정하지 않기에 여러 클럭 주기가 필요하고, 이로 인해 파이프라이닝에 비효율적이다. 반면 RISC는 규격화되어 있어 하나의 명령어가 1클럭 내외로 실행되어 파이프라이닝에 효율적인 특징을 갖는다.

#### 실패하는 경우

파이프라이닝은 무조건 성공하는 기법은 아니다. 파이프라이닝을 적용해도 성능 향상이 이루어지지 않는 경우가 있는데, 이를 **파이프라인 위험**이라고 한다. 이는 **데이터 위험**과 **제어 위험**, **구조 위험**(자원 위험)으로 구분된다.

데이터 위험은 **의존성**에 의해 발생된다. 가령 첫 파이프라인이 완료되고 데이터가 저장되어야만 실행할 수 있다면, 데이터 위험이 발생하고, 파이프라인이 제대로 실행되지 않는다. 

제어 위험은 **프로그램 카운터의 갑작스러운 변화**로 발생한다. Jump나 인터럽트 등으로 프로그램 실행 흐름에 변화가 생기면 미리 인출, 해석 중인 명령어는 그 의미가 사라진다.

구조 위험은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 **ALU, 레지스터**와 같은 CPU 부품을 사용하려고 할 때 발생한다. 
</br></br></br>
# 참고자료

※ 이 글은 [『이것이 컴퓨터 과학이다』](https://product.kyobobook.co.kr/detail/S000214014967) 책을 기반으로, 다양한 자료를 참고해 작성했습니다.